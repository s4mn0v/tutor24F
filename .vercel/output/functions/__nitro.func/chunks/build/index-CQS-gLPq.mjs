import{defineComponent as e,computed as t,h as a,onServerPrefetch as r,ref as s,shallowRef as n,toRef as i,getCurrentInstance as o,unref as l}from"vue";import{Icon as u,getIcon as c,loadIcon as m}from"@iconify/vue";import{getIconCSS as d}from"@iconify/utils/lib/css/icon";import{p,k as y,q as v,r as f,s as h,c as _}from"./entry-B1wW15I9.mjs";import"../nitro/nitro.mjs";import"underscore";import"bluebird/js/release/promise";import"base64-js";import"jszip";import"@xmldom/xmldom";import"@xmldom/xmldom/lib/dom";import"xmlbuilder";import"dingbat-to-unicode";import"fs";import"url";import"os";import"path";import"path-is-absolute";import"pdf.js-extract";import"node:http";import"node:https";import"@vercel/kv";import"@iconify/utils";import"consola/core";import"unhead";import"@unhead/shared";import"vue-router";import"@prisma/client";import"@vueuse/core";import"tailwind-merge";import"vue3-apexcharts";import"vue/server-renderer";async function g(e,t){if(!e)return null;const a=c(e);if(a)return a;let r;const s=m(e).catch((()=>null));return t>0?await Promise.race([s,new Promise((e=>{r=setTimeout((()=>{e()}),t)}))]).finally((()=>clearTimeout(r))):await s,c(e)}function D(e){const a=y().icon,r=(a.collections||[]).sort(((e,t)=>t.length-e.length));return t((()=>{var t;const s=e(),n=s.startsWith(a.cssSelectorPrefix)?s.slice(a.cssSelectorPrefix.length):s,i=(null==(t=a.aliases)?void 0:t[n])||n;if(!i.includes(":")){const e=r.find((e=>i.startsWith(e+"-")));return e?e+":"+i.slice(e.length+1):i}return i}))}const P="NUXT_ICONS_SERVER_CSS",x=e({name:"NuxtIconCss",props:{name:{type:String,required:!0},customize:{type:Function,required:!1}},setup(e){const s=p(),n=y().icon,i=t((()=>e.name?n.cssSelectorPrefix+e.name:"")),o=t((()=>"."+i.value.replace(/([^\w-])/g,"\\$1")));return r((async()=>{var t;{const a=v().icon||{};if(!(null==(t=null==a?void 0:a.serverKnownCssClasses)?void 0:t.includes(i.value))){const t=await g(e.name,n.fetchTimeout).catch((()=>null));if(!t)return null;let a=s.vueApp._context.provides[P];if(a||(a=s.vueApp._context.provides[P]=new Map,s.runWithContext((()=>{f({style:[()=>{let e=Array.from(a.values()).sort().join("");return n.cssLayer&&(e=`@layer ${n.cssLayer} {${e}}`),{innerHTML:e}}]},{tagPriority:"low"})}))),e.name&&!a.has(e.name)){const r=function(t,a=!0){var r;let s=o.value;n.cssWherePseudo&&(s=`:where(${s})`);const i=d(t,{iconSelector:s,format:"compressed",customise:null!=(r=e.customize)?r:n.customize});return n.cssLayer&&a?`@layer ${n.cssLayer} { ${i} }`:i}(t,!1);a.set(e.name,r)}return null}}})),()=>a("span",{class:["iconify",i.value]})}});const w=e({name:"NuxtIconSvg",props:{name:{type:String,required:!0},customize:{type:Function,required:!1}},setup(e,{slots:t}){p();const c=y().icon,m=D((()=>e.name)),d="i-"+m.value;return m.value&&function(...e){var t,a,u,c,m,d,y,v;const f="string"==typeof e[e.length-1]?e.pop():void 0;"string"!=typeof e[0]&&e.unshift(f);let[P,x,w={}]=e;if("string"!=typeof P)throw new TypeError("[nuxt] [asyncData] key must be a string.");if("function"!=typeof x)throw new TypeError("[nuxt] [asyncData] handler must be a function.");const z=p(),S=x;w.server=null==(t=w.server)||t,w.default=null!=(a=w.default)?a:()=>h.value,w.getCachedData=null!=(u=w.getCachedData)?u:()=>z.isHydrating?z.payload.data[P]:z.static.data[P],w.lazy=null!=(c=w.lazy)&&c,w.immediate=null==(m=w.immediate)||m,w.deep=null!=(d=w.deep)?d:h.deep,w.dedupe=null!=(y=w.dedupe)?y:"cancel";const b=w.getCachedData(P,z),C=null!=b;if(!z._asyncData[P]||!w.immediate){null!=(v=z.payload._errors)[P]||(v[P]=h.errorValue);const e=w.deep?s:n;z._asyncData[P]={data:e(C?b:w.default()),pending:s(!C),error:i(z.payload._errors,P),status:s("idle"),_default:w.default}}const q={...z._asyncData[P]};if(delete q._default,q.refresh=q.execute=(e={})=>{var t,a;if(z._asyncDataPromises[P]){if("defer"===(a=null!=(t=e.dedupe)?t:w.dedupe)||!1===a)return z._asyncDataPromises[P];z._asyncDataPromises[P].cancelled=!0}if(e._initial||z.isHydrating&&!1!==e._initial){const t=e._initial?b:w.getCachedData(P,z);if(null!=t)return Promise.resolve(t)}q.pending.value=!0,q.status.value="pending";const r=new Promise(((e,t)=>{try{e(S(z))}catch(e){t(e)}})).then((async e=>{if(r.cancelled)return z._asyncDataPromises[P];let t=e;w.transform&&(t=await w.transform(e)),w.pick&&(t=function(e,t){const a={};for(const r of t)a[r]=e[r];return a}(t,w.pick)),z.payload.data[P]=t,q.data.value=t,q.error.value=h.errorValue,q.status.value="success"})).catch((e=>{if(r.cancelled)return z._asyncDataPromises[P];q.error.value=_(e),q.data.value=l(w.default()),q.status.value="error"})).finally((()=>{r.cancelled||(q.pending.value=!1,delete z._asyncDataPromises[P])}));return z._asyncDataPromises[P]=r,z._asyncDataPromises[P]},q.clear=()=>{return(t=P)in(e=z).payload.data&&(e.payload.data[t]=void 0),t in e.payload._errors&&(e.payload._errors[t]=h.errorValue),e._asyncData[t]&&(e._asyncData[t].data.value=void 0,e._asyncData[t].error.value=h.errorValue,e._asyncData[t].pending.value=!1,e._asyncData[t].status.value="idle"),void(t in e._asyncDataPromises&&(e._asyncDataPromises[t]&&(e._asyncDataPromises[t].cancelled=!0),e._asyncDataPromises[t]=void 0));var e,t},!1!==w.server&&z.payload.serverRendered&&w.immediate){const e=q.refresh({_initial:!0});o()?r((()=>e)):z.hook("app:created",(async()=>{await e}))}const N=Promise.resolve(z._asyncDataPromises[P]).then((()=>q));Object.assign(N,q)}(d,(()=>g(m.value,c.fetchTimeout)),{deep:!1}),()=>{var r;return a(u,{icon:m.value,ssr:!0,customise:null!=(r=e.customize)?r:c.customize},t)}}}),z=e({name:"NuxtIcon",props:{name:{type:String,required:!0},mode:{type:String,required:!1,default:null},size:{type:[Number,String],required:!1,default:null},customize:{type:Function,required:!1}},setup(e,{slots:r}){const s=p(),n=y().icon,i=D((()=>e.name)),o=t((()=>{var t;return(null==(t=s.vueApp)?void 0:t.component(i.value))||("svg"===(e.mode||n.mode)?w:x)})),l=t((()=>{const t=e.size||n.size;return t?{fontSize:Number.isNaN(+t)?t:t+"px"}:null})),u=e.customize||n.customize;return()=>a(o.value,{...n.attrs,name:i.value,class:n.class,style:l.value,customize:u},r)}});export{z as default};
//# sourceMappingURL=index-CQS-gLPq.mjs.map
