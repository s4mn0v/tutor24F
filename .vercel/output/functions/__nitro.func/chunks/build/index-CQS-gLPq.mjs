import{defineComponent as e,computed as t,h as a,onServerPrefetch as r,ref as n,shallowRef as s,toRef as i,getCurrentInstance as o,unref as l}from"vue";import{Icon as u,getIcon as c,loadIcon as d}from"@iconify/vue";import{getIconCSS as m}from"@iconify/utils/lib/css/icon";import{p,k as y,q as v,r as f,s as h,c as _}from"./entry-B1wW15I9.mjs";import"../nitro/nitro.mjs";import"mammoth";import"pdf.js-extract";import"node:http";import"node:https";import"@vercel/kv";import"@iconify/utils";import"consola/core";import"unhead";import"@unhead/shared";import"vue-router";import"@prisma/client";import"@vueuse/core";import"tailwind-merge";import"vue3-apexcharts";import"vue/server-renderer";async function g(e,t){if(!e)return null;const a=c(e);if(a)return a;let r;const n=d(e).catch((()=>null));return t>0?await Promise.race([n,new Promise((e=>{r=setTimeout((()=>{e()}),t)}))]).finally((()=>clearTimeout(r))):await n,c(e)}function D(e){const a=y().icon,r=(a.collections||[]).sort(((e,t)=>t.length-e.length));return t((()=>{var t;const n=e(),s=n.startsWith(a.cssSelectorPrefix)?n.slice(a.cssSelectorPrefix.length):n,i=(null==(t=a.aliases)?void 0:t[s])||s;if(!i.includes(":")){const e=r.find((e=>i.startsWith(e+"-")));return e?e+":"+i.slice(e.length+1):i}return i}))}const P="NUXT_ICONS_SERVER_CSS",w=e({name:"NuxtIconCss",props:{name:{type:String,required:!0},customize:{type:Function,required:!1}},setup(e){const n=p(),s=y().icon,i=t((()=>e.name?s.cssSelectorPrefix+e.name:"")),o=t((()=>"."+i.value.replace(/([^\w-])/g,"\\$1")));return r((async()=>{var t;{const a=v().icon||{};if(!(null==(t=null==a?void 0:a.serverKnownCssClasses)?void 0:t.includes(i.value))){const t=await g(e.name,s.fetchTimeout).catch((()=>null));if(!t)return null;let a=n.vueApp._context.provides[P];if(a||(a=n.vueApp._context.provides[P]=new Map,n.runWithContext((()=>{f({style:[()=>{let e=Array.from(a.values()).sort().join("");return s.cssLayer&&(e=`@layer ${s.cssLayer} {${e}}`),{innerHTML:e}}]},{tagPriority:"low"})}))),e.name&&!a.has(e.name)){const r=function(t,a=!0){var r;let n=o.value;s.cssWherePseudo&&(n=`:where(${n})`);const i=m(t,{iconSelector:n,format:"compressed",customise:null!=(r=e.customize)?r:s.customize});return s.cssLayer&&a?`@layer ${s.cssLayer} { ${i} }`:i}(t,!1);a.set(e.name,r)}return null}}})),()=>a("span",{class:["iconify",i.value]})}});const x=e({name:"NuxtIconSvg",props:{name:{type:String,required:!0},customize:{type:Function,required:!1}},setup(e,{slots:t}){p();const c=y().icon,d=D((()=>e.name)),m="i-"+d.value;return d.value&&function(...e){var t,a,u,c,d,m,y,v;const f="string"==typeof e[e.length-1]?e.pop():void 0;"string"!=typeof e[0]&&e.unshift(f);let[P,w,x={}]=e;if("string"!=typeof P)throw new TypeError("[nuxt] [asyncData] key must be a string.");if("function"!=typeof w)throw new TypeError("[nuxt] [asyncData] handler must be a function.");const z=p(),S=w;x.server=null==(t=x.server)||t,x.default=null!=(a=x.default)?a:()=>h.value,x.getCachedData=null!=(u=x.getCachedData)?u:()=>z.isHydrating?z.payload.data[P]:z.static.data[P],x.lazy=null!=(c=x.lazy)&&c,x.immediate=null==(d=x.immediate)||d,x.deep=null!=(m=x.deep)?m:h.deep,x.dedupe=null!=(y=x.dedupe)?y:"cancel";const C=x.getCachedData(P,z),q=null!=C;if(!z._asyncData[P]||!x.immediate){null!=(v=z.payload._errors)[P]||(v[P]=h.errorValue);const e=x.deep?n:s;z._asyncData[P]={data:e(q?C:x.default()),pending:n(!q),error:i(z.payload._errors,P),status:n("idle"),_default:x.default}}const N={...z._asyncData[P]};if(delete N._default,N.refresh=N.execute=(e={})=>{var t,a;if(z._asyncDataPromises[P]){if("defer"===(a=null!=(t=e.dedupe)?t:x.dedupe)||!1===a)return z._asyncDataPromises[P];z._asyncDataPromises[P].cancelled=!0}if(e._initial||z.isHydrating&&!1!==e._initial){const t=e._initial?C:x.getCachedData(P,z);if(null!=t)return Promise.resolve(t)}N.pending.value=!0,N.status.value="pending";const r=new Promise(((e,t)=>{try{e(S(z))}catch(e){t(e)}})).then((async e=>{if(r.cancelled)return z._asyncDataPromises[P];let t=e;x.transform&&(t=await x.transform(e)),x.pick&&(t=function(e,t){const a={};for(const r of t)a[r]=e[r];return a}(t,x.pick)),z.payload.data[P]=t,N.data.value=t,N.error.value=h.errorValue,N.status.value="success"})).catch((e=>{if(r.cancelled)return z._asyncDataPromises[P];N.error.value=_(e),N.data.value=l(x.default()),N.status.value="error"})).finally((()=>{r.cancelled||(N.pending.value=!1,delete z._asyncDataPromises[P])}));return z._asyncDataPromises[P]=r,z._asyncDataPromises[P]},N.clear=()=>{return(t=P)in(e=z).payload.data&&(e.payload.data[t]=void 0),t in e.payload._errors&&(e.payload._errors[t]=h.errorValue),e._asyncData[t]&&(e._asyncData[t].data.value=void 0,e._asyncData[t].error.value=h.errorValue,e._asyncData[t].pending.value=!1,e._asyncData[t].status.value="idle"),void(t in e._asyncDataPromises&&(e._asyncDataPromises[t]&&(e._asyncDataPromises[t].cancelled=!0),e._asyncDataPromises[t]=void 0));var e,t},!1!==x.server&&z.payload.serverRendered&&x.immediate){const e=N.refresh({_initial:!0});o()?r((()=>e)):z.hook("app:created",(async()=>{await e}))}const T=Promise.resolve(z._asyncDataPromises[P]).then((()=>N));Object.assign(T,N)}(m,(()=>g(d.value,c.fetchTimeout)),{deep:!1}),()=>{var r;return a(u,{icon:d.value,ssr:!0,customise:null!=(r=e.customize)?r:c.customize},t)}}}),z=e({name:"NuxtIcon",props:{name:{type:String,required:!0},mode:{type:String,required:!1,default:null},size:{type:[Number,String],required:!1,default:null},customize:{type:Function,required:!1}},setup(e,{slots:r}){const n=p(),s=y().icon,i=D((()=>e.name)),o=t((()=>{var t;return(null==(t=n.vueApp)?void 0:t.component(i.value))||("svg"===(e.mode||s.mode)?x:w)})),l=t((()=>{const t=e.size||s.size;return t?{fontSize:Number.isNaN(+t)?t:t+"px"}:null})),u=e.customize||s.customize;return()=>a(o.value,{...s.attrs,name:i.value,class:s.class,style:l.value,customize:u},r)}});export{z as default};
//# sourceMappingURL=index-CQS-gLPq.mjs.map
